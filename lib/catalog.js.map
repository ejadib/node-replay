{"version":3,"sources":["catalog.js"],"names":["assert","require","debug","File","Path","Matcher","jsStringEscape","mkpathSync","pathname","existsSync","parent","dirname","mkdirSync","parseHeaders","filename","headerLines","only","headers","Object","create","line","match","slice","name","value","key","toLowerCase","trim","replace","Array","isArray","push","parseRequest","request","requestHeaders","split","methodAndPath","method","path","rawRegexp","regexp","test","inRegexp","flags","RegExp","body","url","parseResponse","response","statusLine","newFormat","version","statusCode","parseInt","statusMessage","rawHeaders","reduce","raw","header","trailers","rawTrailers","readAndInitialParseFile","buffer","readFileSync","parts","toString","length","parts0","Buffer","parts1","writeHeaders","file","item","write","regexps","module","exports","Catalog","constructor","settings","matchers","_basedir","resolve","getFixturesDir","setFixturesDir","dir","find","host","matcherKey","hostSuffix","newMatchers","stat","statSync","isDirectory","files","readdirSync","mapping","_read","fromMapping","save","callback","matcher","uid","customFileNameHeader","Date","now","Math","floor","random","tmpfile","error","setImmediate","createWriteStream","encoding","toUpperCase","chunks","part","end","rename","undefined"],"mappings":"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","file":"catalog.js","sourcesContent":["const assert         = require('assert');\nconst debug          = require('./debug');\nconst File           = require('fs');\nconst Path           = require('path');\nconst Matcher        = require('./matcher');\nconst jsStringEscape = require('js-string-escape');\n\n\nfunction mkpathSync(pathname) {\n  if (File.existsSync(pathname))\n    return;\n  const parent = Path.dirname(pathname);\n  if (File.existsSync(parent))\n    File.mkdirSync(pathname);\n  else {\n    mkpathSync(parent);\n    File.mkdirSync(pathname);\n  }\n}\n\n\n// Parse headers from headerLines.  Optional argument `only` is an array of\n// regular expressions; only headers matching one of these expressions are\n// parsed.  Returns a object with name/value pairs.\nfunction parseHeaders(filename, headerLines, only = null) {\n  const headers = Object.create(null);\n  for (let line of headerLines) {\n    if (line === '')\n      continue;\n    let [name, value] = line.match(/^(.*?)\\:\\s+(.*)$/).slice(1);\n    if (only && !match(name, only))\n      continue;\n\n    const key  = (name || '').toLowerCase();\n    value = (value || '').trim().replace(/^\"(.*)\"$/, '$1');\n    if (Array.isArray(headers[key]))\n      headers[key].push(value);\n    else if (headers[key])\n      headers[key] = [headers[key], value];\n    else\n      headers[key] = value;\n  }\n  return headers;\n}\n\n\nfunction parseRequest(filename, request, requestHeaders) {\n  assert(request, `${filename} missing request section`);\n  const [ methodAndPath, ...headerLines ] = request.split(/\\n/);\n  let method;\n  let path;\n  let rawRegexp;\n  let regexp;\n  if (/\\sREGEXP\\s/.test(methodAndPath)) {\n    [ method, rawRegexp ]  = methodAndPath.split(' REGEXP ');\n    const [ inRegexp, flags ] = rawRegexp.match(/^\\/(.+)\\/(i|m|g)?$/).slice(1);\n    regexp = new RegExp(inRegexp, flags || '');\n  } else\n    [ method, path ] = methodAndPath.split(/\\s/);\n  assert(method && (path || regexp), `${filename}: first line must be <method> <path>`);\n  assert(/^[a-zA-Z]+$/.test(method), `${filename}: method not valid`);\n  const headers = parseHeaders(filename, headerLines, requestHeaders);\n  const body    = headers.body;\n  delete headers.body;\n  const url = path || regexp;\n  return { url, method, headers, body };\n}\n\n\nfunction parseResponse(filename, response, body) {\n  if (response) {\n    const [ statusLine, ...headerLines ] = response.split(/\\n/);\n    const newFormat     = statusLine.match(/HTTP\\/(\\d\\.\\d)\\s+(\\d{3})\\s*(.*)/);\n    const version       = newFormat[1];\n    const statusCode    = parseInt(newFormat[2], 10);\n    const statusMessage = newFormat[3].trim();\n    const headers       = parseHeaders(filename, headerLines);\n    const rawHeaders    = headerLines.reduce(function(raw, header) {\n      const [name, value] = header.split(/:\\s+/);\n      raw.push(name);\n      raw.push(value);\n      return raw;\n    }, []);\n    return { statusCode, statusMessage, version, headers, rawHeaders, body, trailers: {}, rawTrailers: [] };\n  }\n}\n\n\nfunction readAndInitialParseFile(filename) {\n  const buffer  = File.readFileSync(filename);\n  const parts   = buffer.toString('utf8').split('\\n\\n');\n  if (parts.length > 2) {\n    const parts0  = new Buffer(parts[0], 'utf8');\n    const parts1  = new Buffer(parts[1], 'utf8');\n    const body    = buffer.slice(parts0.length + parts1.length + 4);\n    return [ parts[0], parts[1], body ];\n  } else\n    return [ parts[0], parts[1], '' ];\n}\n\n\n// Write headers to the File object.  Optional argument `only` is an array of\n// regular expressions; only headers matching one of these expressions are\n// written.\nfunction writeHeaders(file, headers, only = null) {\n  for (let name in headers) {\n    let value = headers[name];\n    if (only && !match(name, only))\n      continue;\n    if (Array.isArray(value))\n      for (let item of value)\n        file.write(`${name}: ${item}\\n`);\n    else\n      file.write(`${name}: ${value}\\n`);\n  }\n}\n\n\n// Returns true if header name matches one of the regular expressions.\nfunction match(name, regexps){\n  for (let regexp of regexps)\n    if (regexp.test(name))\n      return true;\n  return false;\n}\n\nmodule.exports = class Catalog {\n\n  constructor(settings) {\n    this.settings = settings;\n    // We use this to cache host/host:port mapped to array of matchers.\n    this.matchers = {};\n    this._basedir = Path.resolve('fixtures');\n  }\n\n  getFixturesDir() {\n    return this._basedir;\n  }\n\n  setFixturesDir(dir) {\n    this._basedir = Path.resolve(dir);\n    this.matchers = {};\n  }\n\n  find(host) {\n    let matcherKey = host;\n\n    if (this.settings.hostSuffix) {\n      matcherKey += `.${this.settings.hostSuffix}`; \n    }\n\n    // Return result from cache.\n    const matchers = this.matchers[matcherKey];\n    if (matchers)\n      return matchers;\n\n    // Start by looking for directory and loading each of the files.\n    // Look for host-port (windows friendly) or host:port (legacy)\n    let pathname = `${this.getFixturesDir()}/${matcherKey.replace(':', '-')}`;\n    if (!File.existsSync(pathname))\n      pathname = `${this.getFixturesDir()}/${matcherKey}`;\n    if (!File.existsSync(pathname))\n      return null;\n\n    const newMatchers = this.matchers[matcherKey] || [];\n    this.matchers[matcherKey] = newMatchers;\n\n    const stat = File.statSync(pathname);\n    if (stat.isDirectory()) {\n      const files = File.readdirSync(pathname);\n      for (let file of files) {\n        let mapping = this._read(`${pathname}/${file}`);\n        newMatchers.push(Matcher.fromMapping(host, mapping));\n      }\n    } else {\n      const mapping = this._read(pathname);\n      newMatchers.push(Matcher.fromMapping(host, mapping));\n    }\n\n    return newMatchers;\n  }\n\n  save(host, request, response, callback) {\n    let matcherKey = host;\n\n    if (this.settings.hostSuffix) {\n      matcherKey += `.${this.settings.hostSuffix}`; \n    }\n\n    const matcher = Matcher.fromMapping(host, { request, response });\n    const matchers = this.matchers[matcherKey] || [];\n    matchers.push(matcher);\n    const requestHeaders = this.settings.headers;\n\n    const uid = this.settings.customFileNameHeader ? request.headers[this.settings.customFileNameHeader] : `${ Date.now() }${ Math.floor(Math.random() * 100000) }`;\n    const tmpfile   = `${this.getFixturesDir()}/node-replay.${uid}`;\n    const pathname  = `${this.getFixturesDir()}/${matcherKey.replace(':', '-')}`;\n\n    debug(`Creating ${pathname}`);\n    try {\n      mkpathSync(pathname);\n    } catch (error) {\n      setImmediate(function() {\n        callback(error);\n      });\n      return;\n    }\n\n    const filename = `${pathname}/${uid}`;\n    try {\n      const file = File.createWriteStream(tmpfile, { encoding: 'utf-8' });\n      file.write(`${request.method.toUpperCase()} ${request.url.path || '/'}\\n`);\n      writeHeaders(file, request.headers, requestHeaders);\n      if (request.body) {\n        let body = '';\n        for (let chunks of request.body)\n          body += chunks[0];\n        writeHeaders(file, { body: jsStringEscape(body) });\n      }\n      file.write('\\n');\n      // Response part\n      file.write(`HTTP/${response.version || '1.1'} ${response.statusCode || 200} ${response.statusMessage}\\n`);\n      writeHeaders(file, response.headers);\n      file.write('\\n');\n      for (let part of response.body)\n        file.write(part[0], part[1]);\n      file.end(function() {\n        File.rename(tmpfile, filename, callback);\n      });\n    } catch (error) {\n      callback(error);\n    }\n  }\n\n  _read(filename) {\n    const [request, response, part] = readAndInitialParseFile(filename);\n    const body = [[part, undefined]];\n    return {\n      request:  parseRequest(filename, request, this.settings.headers),\n      response: parseResponse(filename, response, body)\n    };\n  }\n\n};\n\n"]}